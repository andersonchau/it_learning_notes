Authentication : 
Server session : 
after login -> session Id object , generated by Http.getSession();
 -> jsessionID created which identify the session, pass between browser and web container. 

session problem : 
-> heavy loading for saving sessionId in web container (solution : redis as cache)
-> only store in same web container, affect scailibty (solution : redis )
-> CSRF : if cookie captured , vlunerable to attack. 

TOKEN based authentication flow: ( for Web service API)
(1) authen 
(2) server save as cookie or return token
(3) webapp save to cookie or localstorage
(4) when call web services ( send as header ) for authorization.


Cookies rule :
-- max-age, expire , max-age higher priority.
-- cookie is associated with domain 
-- only same domain will get back the cookie for subdomain .abc.com, with preceding dot.
-- jsessionid as cookie 

CSRF and CORS: 
-- cross site request forgery and Cross-Origin Resource Sharing
-- a site contain link to other domain to perform unexpected operations. 
-- CSRF token , web container attach token to response(in meta(for API call), in form hidden field), to ensure the request and response match for authentication. 
-- AJAX by default block call to cross domain , CORS allow resources to be shared by other client request
 e.g. @CrossOrigin(origins = "http://localhost:8080") -- without spring security 
 the mechanism is to add Access-Control-Allow-Origin: http://localhost:8080 header , to allow site of localhost:8080 to access this API.

Access-Control-Allow-Origin/Access-Control-Allow-Methods/Access-Control-Allow-Headers

Spring security configure in centralized way:
http.cors().and().csrf().disable()....
or set filter :
https://stackoverflow.com/questions/40418441/spring-security-cors-filter

====================================================================================================================
