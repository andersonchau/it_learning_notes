Commonly used/practical Oracle SQL at work
And some database stuff.

#Convert date string to DATETIME :
SELECT TO_DATE('2015/05/15 8:30:25', 'YYYY/MM/DD HH:MI:SS') FROM dual;

#Beginning of YEAR, MONTH, DAY : 
SELECT TRUNC(TO_DATE('22-AUG-03'), 'YEAR') FROM DUAL;
SELECT TRUNC(TO_DATE('22-JAN-03'), 'MONTH') FROM DUAL;

#Compare same month
SELECT d1,d2 FROM table1 WHERE TRUNC(TO_DATE(d1), 'MONTH') = TRUNC(TO_DATE(d2), 'MONTH');
order_dt >= TRUNC(SYSDATE) â€” 365

#last 30 days,count at day start :
SELECT productid FROM product where purchase_date > trunc(sysdate-30);
SELECT productid FROM product where purchase_date > trunc(to_date('03/06/2011','mm/dd/yyyy'));


#next one hour : 
SELECT TO_CHAR(sysdate+1/24),'hh:mi:ss') FROM DUAL;

#add month:
SELECT TO_CHAR(ADD_MONTHS(SYSDATE,-50000), 'YYYY AD'),
TO_CHAR(ADD_MONTHS(SYSDATE,-50000), 'YYYY BC') FROM DUAL;

# change for display
ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MON-YY HH:MI:SS AM';




DECODE(E1, E2, E3, E4) IF E1 = E2 THEN E3 ELSE E4
NVL(E1, E2) IF E1 IS NULL THEN E2 ELSE E1
NVL2(E1, E2, E3) IF E1 IS NULL THEN E3 ELSE E2



# If first value NULL, use second , for NVL2, if 1->2->3
SELECT NVL(d1,'no-date') from table1;
SELECT NVL(d1,d2) from table1;
SELECT NVL(d1,d2,'nothing') from table1;
#nvl useful for analytics 
SELECT AVG(NVL(SALE_PRICE,0)) FROM CUST_ORDER;

# case
SELECT co.order_nbr, co.cust_nbr,
CASE WHEN co.expected_ship_dt IS NULL THEN 'NOT YET SCHEDULED'
WHEN co.expected_ship_dt <= SYSDATE THEN 'SHIPPING DELAYED'
WHEN co.expected_ship_dt <= SYSDATE + 2 THEN 'SHIPPING SOON'
ELSE 'BACKORDERED'
END ship_status
FROM cust_order co
WHERE co.ship_dt IS NULL AND co.cancelled_dt IS NULL;

# insert with seq 
INSERT INTO tbl1 (d1,d2) VALUES (my_seq.nextval,'Hello');


# when member_id field is the same, we just want update, not insert, we use MERGE statement
# below is the template example :

MERGE INTO member_staging x
USING (SELECT member_id, first_name, last_name, rank FROM members) y
ON (x.member_id  = y.member_id)
WHEN MATCHED THEN
    UPDATE SET x.first_name = y.first_name, 
                        x.last_name = y.last_name, 
                        x.rank = y.rank
    WHERE x.first_name <> y.first_name OR 
           x.last_name <> y.last_name OR 
           x.rank <> y.rank 
WHEN NOT MATCHED THEN
    INSERT(x.member_id, x.first_name, x.last_name, x.rank)  
    VALUES(y.member_id, y.first_name, y.last_name, y.rank);

#String append : 
SELECT first_name || ' ' || last_name AS customer_name FROM customers;

Some notes :

# direct connection with SQL plus 
username/password@host:port/SID
host_ip:port/SID

# Money Data 
type NUMBER(10,2)

# In Oracle, by default empty String '' equals null

# Excel generated SQL statement example
https://chandoo.org/wp/sql-insert-update-statements-from-csv-files/ 

# JDBC lock table/row 
https://stackoverflow.com/questions/46995155/select-for-update-with-jdbc
1. SELECT * FROM TABLE WHERE id = 10 for update;
2. setAutoCommit(false), need to call commit() explicitly, ref is wrong 
3. CONCUR_UPDATABLE 
4. need to close() if not using try block
5. remember to call updateRow(), but updateRow() will not commit() because setAutoCommit(false)

# VARCHAR2 depends on NLS_CHARACTERSET         
# NVARCHAR2 NLS_NCHAR_CHARACTERSET

# oracle VIEW, view can be live update
CREATE VIEW view_name AS
  SELECT columns
  FROM tables
  [WHERE conditions];

#Setautocommit false -> a transaction is started, need commit. otherwise commit on every statement

#AUTO_INCREMENT in Oracle 
>= Oracle12c
create table t1 (
    c1 NUMBER GENERATED by default on null as IDENTITY,
    c2 VARCHAR2(10)
    );
	
create table t1 (
    c1 NUMBER GENERATED ALWAYS as IDENTITY(START with 1 INCREMENT by 1), # no insert to this column, real AUTO_increment
    c2 VARCHAR2(10)
    );

#Or Oracle 12
CREATE SEQUENCE dept_seq START WITH 1;
CREATE TABLE departments (
  ID           NUMBER(10)    DEFAULT dept_seq.nextval NOT NULL,
  DESCRIPTION  VARCHAR2(50)  NOT NULL);

# check table lock
  select
   c.owner,
   c.object_name,
   c.object_type,
   b.sid,
   b.serial#,
   b.status,
   b.osuser,
   b.machine
from
   v$locked_object a ,
   v$session b,
   dba_objects c
where
   b.sid = a.session_id
and
   a.object_id = c.object_id;
   
# list all table, can use WHERE
SELECT owner, table_name FROM all_tables;


 1.	
Invoke SQL*Plus.

 

 2.	
Query V$SESSION supplying the username for the session you want to terminate:

SELECT SID, SERIAL#, STATUS, SERVER
FROM V$SESSION
WHERE USERNAME = '<username>'

3.	
Execute the ALTER SYSTEM command to terminate the session:

ALTER SYSTEM KILL SESSION '<sid, serial#>'

 

 4.	
Query V$SESSION:

SELECT SID, SERIAL#, STATUS, SERVER
FROM V$SESSION
WHERE USERNAME = '<username>'
Move your mouse over this icon to see the image

 

 5.	
After PMON has cleaned up after the session, the row is removed from V$SESSION:

SELECT SID, SERIAL#, STATUS, SERVER
FROM V$SESSION
WHERE USERNAME = '<username>'
Move your mouse over this icon to see the image

=======================================================================================
#simple table data copy/backup
create table xyz_new as select * from xyz;

=======================================================================================
# SQL plus output -> file.
SET PAGESIZE 0
SET FEEDBACK OFF
SET HEAD OFF
set trimout on;
set trimspool on;
SET LINESIZE 4000 
SET ECHO OFF
SET SERVEROUTPUT ON
SPOOL output.txt
select user_id from users where user_id = 13448493 order by createtime;
SPOOL OFF # a flush here
EXIT
=======================================================================================
# Run sql script 
@c:\sql_script\sql_script.txt
#make sure txt file, environment 
======================================================================================
#Paging :
https://stackoverflow.com/questions/241622/paging-with-oracle

SELECT * FROM
(
	SELECT a.*, rownum r__
	FROM
	(
		SELECT * FROM ORDERS WHERE CustomerID LIKE 'A%'
		ORDER BY OrderDate DESC, ShippingDate DESC
	) a
	WHERE rownum < ((pageNumber * pageSize) + 1 )
)
WHERE r__ >= (((pageNumber-1) * pageSize) + 1)


>= Oracle 12c 
SELECT *
FROM user
ORDER BY first_name
OFFSET 5 ROWS FETCH NEXT 10 ROWS ONLY;
========================================================================================
#Outer join on P table, (+) only appears on one side
SELECT S.SUPPLIER_ID, S.NAME SUPPLIER_NAME, P.PART_NBR, P.NAME PART_NAME
FROM SUPPLIER S, PART P
WHERE P.SUPPLIER_ID (+) = S.SUPPLIER_ID;
========================================================================================
SELECT E.LNAME
FROM EMPLOYEE E
WHERE E.DEPT_ID =(SELECT DEPT_ID FROM DEPARTMENT WHERE NAME = 'ACCOUNTING');
======================================================================================
SELECT E.LNAME
FROM EMPLOYEE E
WHERE E.DEPT_ID (+) =
(SELECT DEPT_ID FROM DEPARTMENT WHERE NAME = 'ACCOUNTING');
#disallowed , workaround :

SELECT E.LNAME
FROM EMPLOYEE E,
(SELECT DEPT_ID FROM DEPARTMENT WHERE NAME = 'ACCOUNTING') V
WHERE E.DEPT_ID (+) = V.DEPT_ID;

=====================================================================
# self join example:
SELECT E.NAME EMPLOYEE, M.NAME MANAGER
FROM EMPLOYEE E, EMPLOYEE M
WHERE E.MANAGER_EMP_ID = M.EMP_ID;
=====================================================================
# insert + select used together 
INSERT INTO table2
(column_name(s))
SELECT column_name(s)
FROM table1;








============================================================================
Other examples : 

SELECT sales_emp_id, COUNT(*)
FROM cust_order
GROUP BY sales_emp_id
HAVING COUNT(*) = (SELECT MAX(COUNT(*))
FROM cust_order
GROUP BY sales_emp_id);

SELECT fname, lname
FROM employee
WHERE dept_id = 3 AND salary >= ALL
(SELECT salary
FROM employee
WHERE dept_id = 3);

#inline view 
SELECT d.dept_id, d.name, emp_cnt.tot
FROM department d,
(SELECT dept_id, COUNT(*) tot
FROM employee
GROUP BY dept_id) emp_cnt
WHERE d.dept_id = emp_cnt.dept_id;

SELECT 'SMALL' name, 0 lower_bound, 999 upper_bound from dual
UNION ALL
SELECT 'MEDIUM' name, 1000 lower_bound, 24999 upper_bound from dual
UNION ALL
SELECT 'LARGE' name, 25000 lower_bound, 9999999 upper_bound from dual;

